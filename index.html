<!DOCTYPE html>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
/>
<link rel="shortcut icon" type="image/jpeg" href="data:," />
<title>üéµ</title>
<style>
  body {
    margin: 0;
    padding: 0;
    font-size: 1rem;
    font-family: system-ui, sans-serif;
  }

  .item {
    padding: 0.5rem;
    font-size: 1rem;
    line-height: 1rem;
    white-space: nowrap;
  }

  @media (pointer: fine) {
    .item {
      padding: 0.3rem;
    }
  }

  .item:hover {
    background-color: #eee;
    cursor: pointer;
  }

  .folder::before {
    content: "üìÅ ";
  }

  .file::before {
    content: "‚ùì ";
  }

  .music::before {
    content: "üéµ ";
  }

  .picture::before {
    content: "üñº ";
  }

  .highlight,
  .highlight:hover {
    background-color: #eef;
  }

  progress {
    height: 2px;
    width: 100%;
    position: fixed;
    top: 0;
  }

  audio {
    background: #f1f3f4;
    z-index: 1;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    width: 100%;
    box-shadow: 0 0 1rem rgba(0, 0, 0, 0.2);
    width: 100%;
    outline: 0;
  }

  #list {
    position: fixed;
    top: 0;
    bottom: 54px;
    left: 0;
    right: 0;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .icon {
    display: inline-block;
    width: 1em;
    height: 1em;
    stroke-width: 0;
    stroke: currentColor;
    fill: currentColor;
  }
</style>

<audio id="player" autoplay loop controls></audio>

<script>
  const player = document.querySelector("audio");
  const scrollTop = [];
  const folderNodeUp = function (event) {
    if (event.which === 1) {
      scrollTop[window.location.pathname.split("/").length - 2] =
        document.querySelector("#list").scrollTop;
      history.pushState(null, null, `${window.location.pathname}${this.textContent}/`);
      getListing();
    } else if (event.which === 2) {
      window.open(`${window.location.pathname}${this.textContent}/`);
    }
  };

  const fileNodeUp = function (event) {
    if (event.which === 1 || event.which === 2) {
      window.open(`/file${window.location.pathname}${this.textContent}`);
    }
  };

  const musicNodeUp = function (event) {
    if (event.which === 2) {
      window.open(`/file${window.location.pathname}${this.textContent}`);
      return;
    }
    if (event.which !== 1) return;
    if (document.querySelector(".highlight")) {
      document.querySelector(".highlight").classList.remove("highlight");
    }
    this.classList.add("highlight");
    player.src = `/file${window.location.pathname}${this.textContent}`;
    player.load();
    document.title = this.textContent;
    if (!"mediaSession" in navigator) return;
    navigator.mediaSession.metadata = new MediaMetadata({
      title: this.textContent.slice(0, -4),
      artist: "",
      album: decodeURI(window.location.pathname).split("/").slice(-2)[0],
      artwork: [
        {
          src: `/file${window.location.pathname}cover.jpg`,
          sizes: "500x500",
          type: "image/jpeg",
        },
      ],
    });
    navigator.mediaSession.setActionHandler("play", () => {
      player.play();
    });
    navigator.mediaSession.setActionHandler("pause", () => {
      player.pause();
    });
    navigator.mediaSession.setActionHandler("seekbackward", () => {
      player.currentTime = player.currentTime - 5;
    });
    navigator.mediaSession.setActionHandler("seekforward", () => {
      player.currentTime = player.currentTime + 5;
    });
    navigator.mediaSession.setActionHandler("previoustrack", () => {
      document.querySelector(".highlight").previousSibling.onmouseup({ which: 1 });
    });
    navigator.mediaSession.setActionHandler("nexttrack", () => {
      document.querySelector(".highlight").nextSibling.onmouseup({ which: 1 });
    });
  };

  const appendChunk = (listNode, chunk) =>
    listNode.append(
      ...chunk.map(({ type, name }) => {
        const itemNode = document.createElement("div");
        itemNode.classList.add("item");
        if (
          [".mp3", "flac", ".m4a", ".ogg", ".wav", "opus"].includes(name.substr(-4).toLowerCase())
        ) {
          itemNode.classList.add("music");
          itemNode.onmouseup = musicNodeUp;
        } else if (type === "directory" || type === "other") {
          itemNode.classList.add("folder");
          itemNode.onmouseup = folderNodeUp;
        } else if ([".jpg", ".png", ".bmp"].includes(name.substr(-4).toLowerCase())) {
          itemNode.classList.add("picture");
          itemNode.onmouseup = fileNodeUp;
        } else {
          itemNode.classList.add("file");
          itemNode.onmouseup = fileNodeUp;
        }
        itemNode.appendChild(document.createTextNode(name));
        return itemNode;
      })
    );

  const getListing = async (scrollTop) => {
    const startTime = performance.now();
    const clearListTimer = setTimeout(() => {
      document.querySelector("#list") && document.body.removeChild(document.querySelector("#list"));
      document.body.appendChild(document.createElement("progress"));
    }, 200);

    const fileList = await fetch(`/api${window.location.pathname}`).then((res) => res.json());

    clearTimeout(clearListTimer);
    document.querySelector("#list") && document.body.removeChild(document.querySelector("#list"));

    const listNode = document.createElement("div");
    listNode.id = "list";
    listNode.style.bottom = getComputedStyle(player).height;
    document.body.appendChild(listNode);

    const chunkList = fileList
      .sort((a, b) => new Date(b.mtime) - new Date(a.mtime))
      .reduce(
        (acc, cur, index, array) => (index % 300 ? acc : [...acc, array.slice(index, index + 300)]),
        []
      );
    appendChunk(listNode, chunkList[0]);
    document.querySelector("progress") ||
      document.body.appendChild(document.querySelector("progress"));
    for (const chunk of chunkList.slice(1)) {
      await new Promise((resolve) =>
        setTimeout(() => {
          appendChunk(listNode, chunk);
          if (
            scrollTop &&
            document.querySelector("#list").scrollHeight -
              document.querySelector("#list").clientHeight >=
              scrollTop
          ) {
            document.querySelector("#list").scrollTop = scrollTop;
          }
          resolve();
        }, 0)
      );
    }
    document.body.removeChild(document.querySelector("progress"));
  };
  getListing();
  window.onpopstate = async () => {
    await getListing(scrollTop[window.location.pathname.split("/").length - 2] || 0);
  };

  window.onkeyup = function (event) {
    let seek = 5;
    if (event.ctrlKey) {
      seek = 30;
    }
    if (event.which === 32) {
      player.src && player.paused ? player.play() : player.pause();
    }
    if (event.which === 37) {
      player.currentTime = player.currentTime < seek ? 0 : player.currentTime - seek;
    }
    if (event.which === 39) {
      player.currentTime =
        player.duration - player.currentTime < seek ? player.duration : player.currentTime + seek;
    }
    if (event.which === 38) {
      player.volume = player.volume > 0.9 ? 1 : player.volume + 0.1;
    }
    if (event.which === 40) {
      player.volume = player.volume < 0.1 ? 0 : player.volume - 0.1;
    }
  };

  window.onkeydown = function (event) {
    if ([32, 37, 38, 39, 40].includes(event.which)) {
      event.preventDefault();
    }
  };

  player.onended = function () {
    if (player.loop) return;
    document.querySelector(".highlight").nextSibling.onmouseup({ which: 1 });
  };
</script>
